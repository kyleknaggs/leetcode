---------------------------------
---------------------------------

9: RANDOM NUMBERS

  Most random numbers generated by computers are not actually random, they are pseudo-random.
  This is because truly random numbers are actuay hard to generate.
  Though computers can do very complicated things they are always following a list of definite steps.
  And it is difficult to produce a list of truly random numbers using a list of definite steps.

  Because of this we often rely on Pseudorandom number generators or Cryptographic random number generators instead.

  PRNG - Pseudorandom number generator
    Generates a number that appears to be random, but is in fact generated using a mathematical formula.
    The numbers created by pseudo-random number generators will also typically repeat after a while.
    That being said the "repeat-cycle" can be as long as a few million numbers.
    The fastest and most common type of random number generator.

  CRNG - Cryptographic random number generator.
    Generates numbers using a mathematical formula that are difficult to predict even if you know the mathematical formula.
    Slower and less common than a pseudorandom number generator but faster than a true random number generator.

  TRNG - True random number generator.
    Generates numbers using a non-deterministic process.
    Examples of non-deterministic processes that can be used may be fluctuations in radio waves, radioactive decay, lava lamps, dice rolls etc.
    These algorithms are typically very slow and not very common as very few algorithms need true randomness.

  https://www.random.org/

---------------------------------
---------------------------------

10: LINEAR CONGRUENTIAL GENERATORS (LCG'S)

  Linear Congruential Generators are the most common type of pseudorandom number generators algorithms.

    They are very fast because they are O(N).
    However, they may not generate every possible number and they are not very random.
    They generate random numbers using the following formula:

      Y = X * A + B (mod M)

        mod: Modulo.
        Y = The next number in the sequence.
        X = The current number in the sequence.

        Y is usually represented by X with n+1 subscript text next to it.
        X is usually represented by X with n subscript text next to it.
        However, because I am unable to write "n+1" or "n" in subscript text using VSCode I used X and Y instead.

    The value used to initialize a random number generator is called a seed value.
    In this instance the seed value would be the value that we select for the first instance of X.
    Different seed value => Different sequence of numbers.

  The largest amount of numbers that a linear congruential generator can produce before repeating itself is the value M used in the LCG equation.
  When an LCG produces the maximum amount of numbers that it can produce, this is known as its full period.
  An LCG that does not meet the criteria listed above will not have its full period.

  An LCG is only able to produce its full period when:

    1. B and M are relatively prime => This means that they must share no common factors other than 1.
    2. A - 1 is divisible by all prime factors of M.
    3. A - 1 is a multiple of 4 if M is a multiple of 4.

  -----------

  An example of a simple linear congruential generator that has a full period.

    A = 5, B = 3, M = 7, X = 0

    1st value = Seed value => 0
    2nd value = 0 * 5 + 3 (mod 7) => 3(mod 7) => 3
    3rd value = 3 * 5 + 3 (mod 7) => 18(mod 7) => 4
    4th value = 4 * 5 + 3 (mod 7) => 23(mod 7) => 2
    5th value = 2 * 5 + 3 (mod 7) => 13(mod 7) => 6
    6th value = 6 * 5 + 3 (mod 7) => 33(mod 7) => 5
    7th value = 5 * 5 + 3 (mod 7) => 28(mod 7) => 0

    * At this point the sequence starts over *

  An example of an LCG that does not have a full period.

    A = 4, B = 3, M = 8, X = 0

    1. B = 3, M = 8 => Because 3 is a prime number it cannot share any factors with 8. (TRUE)
    2. A = 4, M = 8. A - 1 => 3. The only prime factor of M is 2. Because 3 is not divisible by 2, A - 1 is not divisible by all prime factors of M. (FALSE)
    3. A = 4, M = 8. A - 1 => 3. Because 3 is not a multiple of 4, A - 1 is not a multiple of 4.  (FALSE)
    Because all 3 of these rules are not true, we can predict this LCG will not reach its full period.

    1st value = Seed value => 0
    2nd value = 0 * 4 + 3 (mod 8) =>  3 (mod 8) => 3
    3rd value = 3 * 4 + 3 (mod 8) => 15 (mod 8) => 7
    4th value = 7 * 4 + 3 (mod 8) => 31 (mod 8) => 7

    * At this point the sequence continues to repeat 7 forever *

  -----------

  In practice, most LCG's use much higher values than the ones listed above.
  This is because using higher values means that they have much longer periods and are considerably more random than the numbers listed above.

  An MCG is a Multiplicative Congruential Generator.
  It is exactly like an LCG, but uses a B value of 0.

  -----------

  Subscripts

    A small number located below another number is known as a subscript.
    In math, subscripts are commonly used to represent the index of a particular number in a sequence of numbers.
    http://mathforum.org/library/drmath/view/61321.html

  Factors and Prime Numbers

    Factors in mathematics are numbers that can be used to divide another number with no remainder.
    A prime number is number that does not have any factors other than 1 and itself.

      1: Prime
      2: Prime
      3: Prime
      4: Not Prime

      4 is not a prime number because in addition to 1 and 4, 2 is also a factor of 4.
        4/2 => 2 with no remainder.

      https://www.britannica.com/science/factor-mathematics
      https://www.khanacademy.org/math/pre-algebra/pre-algebra-factors-multiples/pre-algebra-prime-numbers/v/prime-numbers

---------------------------------
---------------------------------

11: RANDOMIZING ARRAYS - PART 1 - RANDOMIZATION ALGORITHM


  An example of an algorithm that will randomize the values in an array is as follows:
  An algorithm can do this by:

    Going through all of the indexes in an array.
    For each index in the array, select a random index in the array that is after position i, but before the end of the array.
    The random index that was selected can be called position j.
    The algorithm will then wwap the values in position i and position j.
    Once the values have been swapped i will be incremented by 1, and the process will of selecting a random index will start over again.

  -----------

  // Implementation of this algorithm in JavaScript.
  var exampleArray = [1,2,3,4,5];

  function randomizeArray() {
    var length = exampleArray.length;

    // Go through each index in the array
    for(var i=0; i<length; i++){
      // Calculate a random index j, between index i and the end of the array
      var indexesAfterCurrent = length  - i - 1;
      var randomValue = Math.random() * indexesAfterCurrent + i;
      var randomIndex = Math.round(randomValue);

      // Swap the values in position i and position j
      var valueAtCurrentIndex = exampleArray[i];
      var valueAtRandomIndex = exampleArray[randomIndex];
      exampleArray[i] = valueAtRandomIndex;
      exampleArray[randomIndex] = valueAtCurrentIndex;
    }
  }

  randomizeArray();
  console.log(exampleArray);

  -----------

  Because this algorithm considers each position in the array once, it will take O(N) time.
  If you go through the algorithm and calculate the probability of each value being assigned to a particular index you will discover that the probability of each number being assigned to a particular index is 1/N.
  This means that the algorithm does assign the values randomly.
  However, the true randomness of the numbers is completely dependant on the true randomness of the pseudorandom number generator used in the algorithm.

---------------------------------
---------------------------------

11: RANDOMIZING ARRAYS - PART 2 - RANDOMIZE TWO-DIMENSIONAL ARRAY

  The array that we just created was an O(N) algorithm for randomizing an array.
  Running truly randomized algorithm multiple times does not make the values returned by the algorithm any more random.
  This is why you only need to use the algorithms once.
  To use them more than once would be a waste of time and resources.

  What can you do with an algorithm that randomizes the values in an array?

    1. If you are a teacher and you want to pick random students to perform various chores and you don't want to assign the same person to multiple tasks.
    2. If you want to have a raffle to give away 5 copies of a text book and more than 5 people sign up for the raffle.

    ------

    1. The "repeat until done" algorithm described in the video:

      If given an array of people:

        1. Create a count of the number of people have been picked and set that value to 0.
        2. Create an array called picked that is equal in length to the number of people and set every value in the array to false.
        3. Randomly select a person from the list.
        4. Check to see if they have been picked already.
        5. If they have not, then pick them.
        6. If they have, then repeat the process.

      // A JavaScript implementation of this algorithm:
      function selectFive(people) {
        var numberPicked = 0;
        // Create an array of the same length with every value set to false.
        var picked = people.map(function(){
          return false;
        });

        do {
          // Generate a random index between 0 and people.length.
          var randomIndex = Math.floor(Math.random() * people.length);

          // If the corresponding index in the picked array has a value of false.
          // Change the value of picked[i] to true.
          // Increment numberPicked by 1.
          if(picked[randomIndex] === false){
            picked[randomIndex] = true;
            numberPicked++;
          }

        } while (numberPicked < 5);

        return picked;
      }

      selectFive(["Kyle","Alex","Charlotte","Heidi","Richard","Shylah","John","Anabelle","Paula","Damian"]);

      This algorithm works.
      It is also fairly quick.
      However, if the algorithm does select somebody that has been picked already, then the loop will have to run an additional time.
      Also, if the algorithm selects somebody who has already been selected a number of times, then the algorithm can take a very long time to finish.

    ------

    2. The "randomize an entire array" algorithm described in the video:

      This solution is simpler, than the original, repeat until done algorithm.
      The steps in this algorithm will be as follows:

        If given an array of people:
          1. Randomize the order of the all of the people in the array.
          2. Give books to the first 5 people.

      // A JavaScript implementation of the algorithm:
      function selectFive(people) {
        var numberOfPeople = people.length;

        for(var i = 0; i<numberOfPeople - 1; i++){
          var numberOfIndexesLeft = numberOfPeople - i;
          var randomIndex = i + Math.floor(Math.random() * numberOfIndexesLeft);
          var valueAtCurrentIndex = people[i];
          var valueAtRandomIndex = people[randomIndex];

          // Swap values
          people[i] = valueAtRandomIndex;
          people[randomIndex] = valueAtCurrentIndex;
        }

        var selectedPeople = people.slice(0,5);
        return selectedPeople;
      }

      var people = ["Kyle","Alex","Charlotte","Heidi","Richard","Shylah","John","Anabelle","Paula","Damian"];
      selectFive(people);


      This algorithm works, but it may do a lot of unecessary work if you have a list of 10,000 people.

    ------

    3. The "randomize a part of an array" algorithm described in the video:

      This solution, is slightly more complex than the "randomize an entire array" algorithm.
      However, if you are fed a really long list of people, you only have to do the work to randomize the first 5 entries in the array.

      The steps in this algorithm will be as follows:

        If given an array of people:
          1. Randomize the order of the first 5 people in the array.
          2. Copy the first values for the first 5 people to a new array.

        // A JavaScript implementation of the algorithm:
        function selectFive(people) {
          var numberOfPeople = people.length;

          for(var i = 0; i<5; i++){
            var numberOfIndexesLeft = numberOfPeople - i;
            var randomIndex = i + Math.floor(Math.random() * numberOfIndexesLeft);
            var valueAtCurrentIndex = people[i];
            var valueAtRandomIndex = people[randomIndex];

            // Swap values
            people[i] = valueAtRandomIndex;
            people[randomIndex] = valueAtCurrentIndex;
          }

          var selectedPeople = people.slice(0,5);
          return selectedPeople;
        }

        var people = ["Kyle","Alex","Charlotte","Heidi","Richard",6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
        selectFive(people);
        // The algorithm returns an array with 5 random values from the people array
        // Note that after the first 5 indexes in the array, none of the values have been moved unless they have been swapped out with one of the first 5 indexes.
        // This is because the algorithm stopped going through every value in the array after this point.

    ------

      4. Make the number of indexes that can be selected dynamic:

        // A JavaScript implementation of an algorithm that can select a random list of N values from an array:
        function selectFromList(people, numberFromList) {
          var numberOfPeople = people.length;

          for(var i = 0; i<numberFromList; i++){
            var numberOfIndexesLeft = numberOfPeople - i;
            var randomIndex = i + Math.floor(Math.random() * numberOfIndexesLeft);
            var valueAtCurrentIndex = people[i];
            var valueAtRandomIndex = people[randomIndex];

            // Swap values
            people[i] = valueAtRandomIndex;
            people[randomIndex] = valueAtCurrentIndex;
          }

          var selectedPeople = people.slice(0,numberFromList);
          return selectedPeople;
        }

        var people = ["Kyle","Alex","Charlotte","Heidi","Richard",6, 7, 8, 9, 10];
        selectFromList(people,5);

---------------------------------
---------------------------------

12: GCD